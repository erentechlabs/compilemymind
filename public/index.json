[{"content":" üëã Welcome! # I‚Äôm Eren, the creator of Compile My Mind ‚Äî a space where I share my journey, projects, and ideas in software development and technology.\nI‚Äôm passionate about coding, system design, and exploring new technologies. For me, it‚Äôs not just about using tools ‚Äî it‚Äôs about understanding how they work, building with them, and sharing what I learn along the way.\nWhat drives me is the excitement of learning, improving, and connecting with people who share the same passion. Through Compile My Mind, I document my growth as a developer and collaborate with like-minded tech enthusiasts.\n","date":"24 October 2025","externalUrl":null,"permalink":"/","section":"","summary":"\u003ch2 class=\"relative group\"\u003eüëã Welcome!\n    \u003cdiv id=\"-welcome\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#-welcome\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eI‚Äôm Eren, the creator of \u003cstrong\u003eCompile My Mind\u003c/strong\u003e ‚Äî a space where I share my journey, projects, and ideas in software development and technology.\u003c/p\u003e","title":"","type":"page"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/tags/softwaredevelopment/","section":"Tags","summary":"","title":"SoftwareDevelopment","type":"tags"},{"content":"This post explains some of the most useful Spring annotations with minimal code you can paste into a project. We‚Äôll cover what each annotation does, when to use it, and a short example.\n@EnableScheduling and @Scheduled # What they do @EnableScheduling: Turns on Spring‚Äôs scheduled task processing. @Scheduled: Marks a method to run on a schedule. import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Configuration @EnableScheduling class SchedulingConfig { } @Component class ReportScheduler { // Runs every 5 seconds after previous start @Scheduled(fixedRate = 5_000) public void exportSummary() { System.out.println(\u0026#34;exportSummary @ \u0026#34; + java.time.Instant.now()); } // Cron: 09:00 Monday‚ÄìFriday in Europe/Istanbul @Scheduled(cron = \u0026#34;0 0 9 * * MON-FRI\u0026#34;, zone = \u0026#34;Europe/Istanbul\u0026#34;) public void morningDigest() { System.out.println(\u0026#34;morningDigest @ \u0026#34; + java.time.Instant.now()); } } @EnableAsync and @Async # What they do @EnableAsync: Enables Spring‚Äôs async method execution infrastructure. @Async: Runs a method on a separate thread (from a configured executor). import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableAsync; import org.springframework.scheduling.annotation.Async; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import org.springframework.stereotype.Service; import java.util.concurrent.CompletableFuture; import java.util.concurrent.Executor; @Configuration @EnableAsync class AsyncConfig { @Bean(name = \u0026#34;taskExecutor\u0026#34;) Executor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(4); executor.setMaxPoolSize(8); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-\u0026#34;); executor.initialize(); return executor; } } @Service class EmailService { @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Void\u0026gt; sendWelcomeEmail(String to) { try { // simulate I/O Thread.sleep(500); System.out.println(\u0026#34;sent welcome email to: \u0026#34; + to); return CompletableFuture.completedFuture(null); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } } @Component and @Service # What they do @Component: Generic stereotype to mark a class for component scanning. @Service: Specialization of @Component, semantically indicating business logic. import org.springframework.stereotype.Component; import org.springframework.stereotype.Service; @Component class SlugGenerator { String toSlug(String title) { return title.toLowerCase().replaceAll(\u0026#34;[^a-z0-9]+\u0026#34;, \u0026#34;-\u0026#34;).replaceAll(\u0026#34;(^-|-$)\u0026#34;, \u0026#34;\u0026#34;); } } @Service class BlogService { private final SlugGenerator slugGenerator; BlogService(SlugGenerator slugGenerator) { this.slugGenerator = slugGenerator; } String createSlug(String title) { return slugGenerator.toSlug(title); } } @Configuration and @Bean # What they do @Configuration: Declares a class that defines beans via @Bean methods. @Bean: Declares a Spring bean returned by the annotated method. import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Service; import java.time.Clock; @Configuration class AppConfig { @Bean Clock clock() { return java.time.Clock.systemUTC(); } } @Service class TimeService { private final Clock clock; TimeService(Clock clock) { this.clock = clock; } java.time.Instant now() { return java.time.Instant.now(clock); } } Tips and gotchas # @Async self-invocation: Calls within the same class won‚Äôt go through the proxy, so @Async won‚Äôt take effect. Call from another Spring bean. @Async return types: Prefer CompletableFuture\u0026lt;T\u0026gt; for error handling. For void, use an AsyncUncaughtExceptionHandler if you need to observe errors. Scheduling threads: Default scheduler is limited. For parallel schedules, define a TaskScheduler bean or use ThreadPoolTaskScheduler. Cron time zone: Always set the zone attribute if your business time zone differs from server time. @Configuration vs @Component: Use @Configuration for full configuration (ensures @Bean methods return managed singletons even when called within the class). ","date":"24 October 2025","externalUrl":null,"permalink":"/posts/spring-annotations-scheduling-async-component-service-configuration-bean/","section":"Posts","summary":"\u003cp\u003eThis post explains some of the most useful Spring annotations with minimal code you can paste into a project. We‚Äôll cover what each annotation does, when to use it, and a short example.\u003c/p\u003e","title":"Spring Annotations Guide: @EnableScheduling, @Scheduled, @Async, @EnableAsync, @Service, and @Configuration Examples","type":"posts"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/tags/springboot/","section":"Tags","summary":"","title":"SpringBoot","type":"tags"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/categories/technology/","section":"Categories","summary":"","title":"Technology","type":"categories"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/tags/techtrends/","section":"Tags","summary":"","title":"TechTrends","type":"tags"},{"content":"Java 25 (JDK 25) is here ‚Äî and it‚Äôs an LTS release. That means most vendors will support it for years, and many teams will plan upgrades from JDK 17 or 21 directly to 25. In this post, I‚Äôll walk through the highlights that matter in real projects: language changes, concurrency improvements (Project Loom), runtime and GC work, observability via JFR, security/crypto, and AOT ergonomics.\nThis post is based on the official OpenJDK pages and JEPs for JDK 25.\nQuick Summary # LTS release with 18 JEPs. See the official list below. Language \u0026amp; syntax: Primitive types in patterns/switch (3rd preview), module import declarations, compact source files \u0026amp; instance main methods, flexible constructor bodies. Concurrency (Loom): Structured Concurrency (5th preview), Scoped Values (finalized). Observability (JFR): CPU-time profiling (experimental), method timing \u0026amp; tracing, cooperative sampling. Performance \u0026amp; memory: Compact object headers, Generational Shenandoah GC. Compute/SIMD: Vector API reaches its 10th incubator. Security \u0026amp; crypto: PEM encodings (preview), Key Derivation Function API. Language and Syntax Improvements # Primitive Types in Patterns, instanceof, and switch (Third Preview) ‚Äî JEP 507\nBrings pattern matching to primitives, improving expressiveness in switch and instanceof scenarios. Still a preview: enable with --enable-preview while evaluating in production-like tests. Object x = 42; // instanceof with a primitive pattern if (x instanceof int i) { System.out.println(i + 1); } // switch with primitive patterns switch (x) { case int i -\u0026gt; System.out.println(\u0026#34;int: \u0026#34; + i); case long l -\u0026gt; System.out.println(\u0026#34;long: \u0026#34; + l); case double d -\u0026gt; System.out.println(\u0026#34;double: \u0026#34; + d); default -\u0026gt; System.out.println(\u0026#34;other: \u0026#34; + x); } Module Import Declarations ‚Äî JEP 511\nStreamlines how code refers to modules and their content, complementing package-level imports. // Import all exported packages from the java.sql module import module java.sql; // Then regular package imports work as usual import java.sql.Connection; import java.sql.DriverManager; class Demo { void main() { try (Connection conn = DriverManager.getConnection( \u0026#34;jdbc:postgresql://localhost/db\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;p\u0026#34;)) { System.out.println(conn.getMetaData().getURL()); } catch (Exception e) { e.printStackTrace(); } } } Compact Source Files and Instance Main Methods ‚Äî JEP 512\nMakes small programs and examples easier to write and run with a leaner source file format and support for instance main methods. // Instance main method (no public/static/String[] args) class HelloWorld { void main() { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } java HelloWorld.java Flexible Constructor Bodies ‚Äî JEP 513\nEases constraints in constructors, improving readability and reducing boilerplate in common patterns. class A { A(int x) { System.out.println(\u0026#34;A(\u0026#34; + x + \u0026#34;)\u0026#34;); } } class B extends A { private final int y; B(int y) { // Prologue: statements before the explicit constructor invocation if (y \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;y must be \u0026gt;= 0\u0026#34;); System.out.println(\u0026#34;Preparing...\u0026#34;); // Explicit superclass constructor call super(y); // Epilogue: statements after the invocation this.y = y; System.out.println(\u0026#34;Done.\u0026#34;); return; // allowed in the epilogue (no expression) } } Concurrency \u0026amp; Loom # Structured Concurrency (Fifth Preview) ‚Äî JEP 505\nA higher-level API for managing related tasks as a single unit, leading to clearer code and predictable cancellation/error handling. Preview status lets the API evolve with real-world feedback. import java.util.concurrent.StructuredTaskScope; String render() throws Exception { try (var scope = StructuredTaskScope.\u0026lt;String, Void\u0026gt;open()) { var userTask = scope.fork(() -\u0026gt; fetchUser()); var ordersTask = scope.fork(() -\u0026gt; fetchOrders()); scope.join(); // wait for both subtasks to complete return \u0026#34;%s | %s\u0026#34;.formatted(userTask.get(), ordersTask.get()); } } Scoped Values ‚Äî JEP 506\nFinalized. Provides a safe, immutable, thread-local-like mechanism for sharing data within a call scope, especially effective with virtual threads. // Define a scoped value static final java.lang.ScopedValue\u0026lt;String\u0026gt; REQUEST_ID = java.lang.ScopedValue.newInstance(); void handle(Request req) { java.lang.ScopedValue.where(REQUEST_ID, req.id()).run(() -\u0026gt; { service(); }); } void service() { System.out.println(\u0026#34;rid=\u0026#34; + REQUEST_ID.get()); } Observability with JFR # JFR CPU-Time Profiling (Experimental) ‚Äî JEP 509\nAdds better attribution of CPU time to Java code paths for more accurate performance analysis. JFR Method Timing \u0026amp; Tracing ‚Äî JEP 520\nRicher, lower-overhead method-level timing and trace events to diagnose latency and hotspots. JFR Cooperative Sampling ‚Äî JEP 518\nImproves sampling behavior and consistency across runtimes. # Start a JFR recording and dump on exit java -XX:StartFlightRecording=filename=profile.jfr,dumponexit=true -jar app.jar # View CPU-time hot methods (new view in JDK 25) jfr view cpu-time-hot-methods profile.jfr # Record method timing for static initializers and dump to file java \u0026#39;-XX:StartFlightRecording:method-timing=::\u0026lt;clinit\u0026gt;,filename=clinit.jfr\u0026#39; -jar app.jar # View method timing results jfr view method-timing clinit.jfr Performance, Memory, and GC # Compact Object Headers ‚Äî JEP 519\nReduces object header size on supported platforms to lower memory footprint and improve cache locality. Generational Shenandoah ‚Äî JEP 521\nIntroduces a generational mode for Shenandoah GC, improving throughput and latency for long-lived services. # Enable Shenandoah in generational mode java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -jar app.jar Remove the 32-bit x86 Port ‚Äî JEP 503\nCleans up legacy maintenance burden; modern Java focuses on x64 and ARM64. AOT Ergonomics and Profiling # Ahead-of-Time Command-Line Ergonomics ‚Äî JEP 514 Smoother CLI options and defaults when experimenting with AOT builds. Ahead-of-Time Method Profiling ‚Äî JEP 515 Helps guide AOT compilation decisions with targeted profiling data. # One-step training + cache creation java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App # Production run using the AOT cache java -XX:AOTCache=app.aot -cp app.jar com.example.App Vector API (Incubator) # Vector API (Tenth Incubator) ‚Äî JEP 508\nContinued refinement of a portable, explicit SIMD API for data-parallel operations, mapping efficiently to modern CPU instructions. As an incubator, it remains behind --add-modules jdk.incubator.vector for now. import jdk.incubator.vector.*; static final VectorSpecies\u0026lt;Float\u0026gt; SPECIES = FloatVector.SPECIES_PREFERRED; void vectorCompute(float[] a, float[] b, float[] c) { int i = 0; int ub = SPECIES.loopBound(a.length); for (; i \u0026lt; ub; i += SPECIES.length()) { var va = FloatVector.fromArray(SPECIES, a, i); var vb = FloatVector.fromArray(SPECIES, b, i); var vc = va.mul(va).add(vb.mul(vb)).neg(); vc.intoArray(c, i); } for (; i \u0026lt; a.length; i++) { c[i] = -(a[i] * a[i] + b[i] * b[i]); } } # Run with the incubator module java --add-modules jdk.incubator.vector VectorDemo Security \u0026amp; Cryptography # PEM Encodings of Cryptographic Objects (Preview) ‚Äî JEP 470 First-class support for reading/writing PEM-encoded material, simplifying interoperability with common tooling. Key Derivation Function API ‚Äî JEP 510 Standardized APIs for modern KDFs, making secure key derivation more approachable and consistent. // KDF (HKDF-SHA256) example ‚Äî derive a 32-byte AES key import javax.crypto.KDF; import javax.crypto.SecretKey; import java.security.spec.AlgorithmParameterSpec; import javax.crypto.spec.HKDFParameterSpec; byte[] initialKeyMaterial = /* ... */ null; byte[] salt = /* ... */ null; byte[] info = /* ... */ null; KDF hkdf = KDF.getInstance(\u0026#34;HKDF-SHA256\u0026#34;); AlgorithmParameterSpec params = HKDFParameterSpec.ofExtract() .addIKM(initialKeyMaterial) .addSalt(salt) .thenExpand(info, 32); SecretKey key = hkdf.deriveKey(\u0026#34;AES\u0026#34;, params); // PEM encode/decode (Preview) import java.security.PEMEncoder; import java.security.PEMDecoder; import java.security.KeyPair; import java.security.interfaces.ECPublicKey; // Encode a key pair as PEM text var pe = PEMEncoder.of(); String pem = pe.encodeToString(new KeyPair(publicKey, privateKey)); // Decode with the expected type var pd = PEMDecoder.of(); ECPublicKey pub = pd.decode(pem, ECPublicKey.class); References # JDK 25 overview: https://openjdk.org/projects/jdk/25/ JDK 25 feature list (JEPs): https://openjdk.org/projects/jdk/25/ JEP index: https://openjdk.org/jeps/0 Conclusion # JDK 25 is a solid LTS that continues the steady modernization of Java: safer and clearer concurrency, better profiling, smarter memory layout, and practical language polish. If you‚Äôre on JDK 17 or 21, this is a compelling target for your next upgrade window ‚Äî especially if you benefit from Loom, JFR improvements, or reduced memory overhead.\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/new-features-in-java-25/","section":"Posts","summary":"\u003cp\u003eJava 25 (JDK 25) is here ‚Äî and it‚Äôs an LTS release. That means most vendors will support it for years, and many teams will plan upgrades from JDK 17 or 21 directly to 25. In this post, I‚Äôll walk through the highlights that matter in real projects: language changes, concurrency improvements (Project Loom), runtime and GC work, observability via JFR, security/crypto, and AOT ergonomics.\u003c/p\u003e","title":"What‚Äôs New in Java 25 (JDK 25)","type":"posts"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/tags/problemsolving/","section":"Tags","summary":"","title":"ProblemSolving","type":"tags"},{"content":"Removing duplicates from a sorted array is a common coding interview question.\nIt‚Äôs simple at first glance, but it‚Äôs also a great way to learn in-place array manipulation and the two-pointer pattern.\nIn this article, we‚Äôll break it down so even if you‚Äôre new to Java, you‚Äôll understand not just how to do it, but why it works.\nWhy This Problem is Important # Teaches two-pointer logic: A fundamental pattern in algorithm design. In-place modification: Useful when you want to save memory. Common interview question: Appears often in technical screenings. Problem Overview # We are given:\nAn integer array nums, sorted in non-decreasing order. We need to: Remove duplicates so that each unique element appears only once. Keep the relative order of elements the same. Modify the array in-place without creating another array. Return k, the number of unique elements. The values beyond index k-1 don‚Äôt matter.\nExample # int[] nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; Output\nk = 5\nThe array nums is modified to:\n[0, 1, 2, 3, 4, _, _, _, _, _]\nThe underscores mean that the values at those indices are irrelevant after processing.\nThought Process # Because the array is already sorted:\nAll duplicates will be next to each other. This makes it easy to detect duplicates by comparing the current element with the previous one. We can:\nUse a pointer k to track where the next unique element should go. Iterate through the array starting from index 1. If the current element is different from the previous one, put it at index k and increment k. Step-by-Step Flow # Imagine nums = [0,0,1,1,1,2,2,3,3,4]:\nStart with k = 1 (because the first element is always unique). Move through the array with index i: If nums[i] != nums[i - 1], it‚Äôs a new number ‚Üí put it at nums[k], then k++. At the end, k tells us how many unique numbers there are. Complexity # Time Complexity: O(n) ‚Üí We scan the array once. Space Complexity: O(1) ‚Üí No extra array, we modify in-place. Final Code # public static int removeDuplicates(int[] nums) { int k = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { nums[k] = nums[i]; k++; } } return k; } ","date":"9 August 2025","externalUrl":null,"permalink":"/posts/remove-duplicates-from-sorted-array/","section":"Posts","summary":"\u003cp\u003eRemoving duplicates from a sorted array is a common coding interview question.\u003cbr\u003e\nIt‚Äôs simple at first glance, but it‚Äôs also a great way to learn \u003cstrong\u003ein-place array manipulation\u003c/strong\u003e and the \u003cstrong\u003etwo-pointer pattern\u003c/strong\u003e.\u003c/p\u003e","title":"Remove Duplicates from Sorted Array ‚Äî The Two-Pointer Solution","type":"posts"},{"content":"Java is truly an amazing programming language. And among its rich toolkit, Spring Boot definitely stands out as a powerful building block. With Spring Boot, we build fast, effective, and sustainable applications. In this article, we‚Äôll take a closer look at the core layers of Spring Boot: Controller, Service, and Repository annotations.\nWhy Layered Architecture? # Before jumping in, let‚Äôs quickly understand why layered architecture matters:\nSeparation of concerns: Makes code easier to read and maintain. Testability: Each layer can be tested independently. Reusability: Business logic can be reused in different parts. Scalability: Easier to extend and modify. Controller # Controller is the layer that handles incoming HTTP requests. It listens to what the client asks for and directs the request to the appropriate handler. When building REST APIs, we usually use @RestController which automatically returns JSON or XML responses.\nWe handle HTTP requests using @RequestMapping or its shortcuts like @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping.\n@RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired UserService userService; @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getUser(@PathVariable Long id) { UserDto user = userService.getUserById(id); return ResponseEntity.ok(user); } @PostMapping public ResponseEntity\u0026lt;UserDto\u0026gt; createUser(@RequestBody UserDto userDto) { UserDto createdUser = userService.createUser(userDto); return ResponseEntity.status(HttpStatus.CREATED).body(createdUser); } } Service # The Service layer is where the business logic lives. Data coming from the controller is processed here ‚Äî validations, calculations, and any rules specific to the domain are handled in this layer. It‚Äôs the brain of the application.\nMarking a class with @Service lets Spring recognize it as a service component and automatically inject it where needed.\n@Service public class UserService { @Autowired UserRepository userRepository; public UserDto getUserById(Long id) { User user = userRepository.findById(id) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;User not found\u0026#34;)); return convertToDto(user); } public UserDto createUser(UserDto userDto) { User user = convertToEntity(userDto); User savedUser = userRepository.save(user); return convertToDto(savedUser); } } Repository # Repository is the data access layer, responsible for communicating with the database. Usually defined as an interface extending Spring Data interfaces like JpaRepository or CrudRepository.\nCrudRepository provides basic CRUD operations. JpaRepository extends CrudRepository and also offers pagination and sorting support. You can also write custom queries using the @Query annotation when standard methods aren‚Äôt enough.\n@Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { List\u0026lt;User\u0026gt; findByLastName(String lastName); @Query(\u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmail(@Param(\u0026#34;email\u0026#34;) String email); } How These Layers Work Together # A typical request flow goes like this:\nClient sends an HTTP request. Controller receives the request and extracts data. Controller calls the Service layer. Service processes the business logic and calls the Repository layer. Repository interacts with the database. Service returns processed data back to the Controller. Controller sends the response to the client. Summary # Layer Responsibility Annotations Example Interfaces Controller Handles HTTP requests \u0026amp; routing @RestController - Service Implements business logic @Service - Repository Manages data access @Repository JpaRepository, CrudRepository Conclusion # Using layered architecture with Controller, Service, and Repository in Spring Boot helps you write code that is clean, testable, and maintainable. These annotations clearly separate responsibilities, making your application easier to build and evolve.\n","date":"7 August 2025","externalUrl":null,"permalink":"/posts/spring-boot-layered-architecture/","section":"Posts","summary":"\u003cp\u003eJava is truly an amazing programming language. And among its rich toolkit, Spring Boot definitely stands out as a powerful building block. With Spring Boot, we build fast, effective, and sustainable applications. In this article, we‚Äôll take a closer look at the core layers of Spring Boot: \u003cstrong\u003eController\u003c/strong\u003e, \u003cstrong\u003eService\u003c/strong\u003e, and \u003cstrong\u003eRepository\u003c/strong\u003e annotations.\u003c/p\u003e","title":"Understanding Controller, Service, and Repository in Spring Boot","type":"posts"},{"content":"LeetCode problems can sometimes be frustrating, but other times they can be genuinely fun. What I want to talk about today definitely falls into the fun category. üòä\nImagine we only have the characters (), {}, and [] to work with. We want to check whether every opening parenthesis, square bracket, and curly brace is correctly closed in the given string.\nFor example, inputs like () or ({[]}) are valid, while something like ()[]{}{ would be invalid because of the unclosed brace at the end.\nThere are several ways to solve this, but today I‚Äôll walk you through a method that uses a data structure called a Stack.\nQuick Refresher: What is a Stack? # A Stack is a data structure that stores items in a last-in, first-out (LIFO) manner. Think of it like a stack of plates‚Äîwhat goes in last comes out first. Here\u0026rsquo;s a simple visual to imagine it: Now let‚Äôs apply this to our parentheses validation problem.\nStep-by-Step Solution # We will write a method that takes a string input, such as \u0026ldquo;()[]{}\u0026rdquo;, and returns true if the parentheses are valid, or false if they‚Äôre not.\n1. Define the Method # public static boolean isValid(String s) The input s will be a string like \u0026ldquo;()[]{}\u0026rdquo;. We return a boolean indicating whether the parentheses are valid.\n2. Declare a Stack # We‚Äôll use a Stack to keep track of opening brackets:\nStack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); 3. Iterate Through the Characters # We loop through each character in the string:\nfor (char c : s.toCharArray()) 4. Push Opening Brackets onto the Stack # If we encounter an opening bracket, we push it onto the stack:\nif (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } 5. Handle Closing Brackets # If we encounter a closing bracket, we first check if the stack is empty. If it is, that means there was no corresponding opening bracket, so we return false.\nThen, we look at the top of the stack using peek() (without removing it) to check if it matches the closing bracket. If it doesn‚Äôt match, we return false. If it does, we remove the top of the stack using pop():\nelse { if (stack.isEmpty()) return false; char top = stack.peek(); if ((c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;(\u0026#39;) || (c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;[\u0026#39;) || (c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;{\u0026#39;)) { return false; } stack.pop(); } 6. Final Validation # If the stack is empty at the end, that means all opening brackets had matching closing brackets. Otherwise, some were left unmatched.\nreturn stack.isEmpty(); Summary # Here‚Äôs the complete method:\npublic static boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty()) return false; char top = stack.peek(); if ((c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;(\u0026#39;) || (c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;[\u0026#39;) || (c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;{\u0026#39;)) { return false; } stack.pop(); } } return stack.isEmpty(); } ","date":"6 August 2025","externalUrl":null,"permalink":"/posts/how-to-solve-leetcode-valid-parentheses-using-stack-in-java/","section":"Posts","summary":"\u003cp\u003eLeetCode problems can sometimes be frustrating, but other times they can be genuinely fun. What I want to talk about today definitely falls into the fun category. üòä\u003c/p\u003e\n\u003cp\u003eImagine we only have the characters (), {}, and [] to work with. We want to check whether every opening parenthesis, square bracket, and curly brace is correctly closed in the given string.\u003c/p\u003e","title":"How to Solve LeetCode's Valid Parentheses Problem Using Stack in Java","type":"posts"},{"content":"Spring Framework provides a powerful Dependency Injection (DI) mechanism to manage application components. In this system, objects are managed by an IoC (Inversion of Control) container. But how do we tell Spring which classes or objects it should manage?\nThere are two common approaches:\n@Component @Bean Although both serve the same end goal‚Äîregistering a bean with the Spring container‚Äîthey work in different ways and are used in different contexts. Let‚Äôs explore their differences with examples and best practices.\nWhat is @Component? # @Component is a class-level annotation that tells Spring to automatically detect and register the class as a bean during component scanning.\nimport org.springframework.stereotype.Component; @Component public class MyService { public void doSomething() { System.out.println(\u0026#34;Component-based service is working!\u0026#34;); } } üîç Note: Annotations like @Service, @Repository, and @Controller are specializations of @Component. They provide semantic meaning in layered architectures.\nTo enable component scanning, you need to annotate your configuration class like this:\n@Configuration @ComponentScan(basePackages = \u0026#34;com.example\u0026#34;) public class AppConfig { } What is @Bean? # @Bean is used to explicitly declare a bean in a method inside a @Configuration class. It\u0026rsquo;s perfect for registering beans manually or configuring third-party objects.\nimport org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } } Feature Component Bean Placement On the class On a method Registration Automatic via scanning Explicit via method Flexibility Less flexible More flexible External Libraries Not suitable Suitable Dependency Injection Via constructor or field Via method parameters When Should You Use Each? # Use Component when: # You control the class source code.\nYou want automatic discovery and registration.\nYou‚Äôre organizing your app into layers (@Service, @Repository, etc.).\nUse Bean when: # You\u0026rsquo;re working with external libraries or third-party classes.\nYou need to manually configure or customize the object.\nYou want fine-grained control over bean creation.\nConclusion # Both @Component and @Bean are essential tools for defining Spring beans, but they shine in different scenarios.\nUse @Component for classes you write and control.\nUse @Bean for manual configuration, third-party classes, or when you need full control over instantiation.\nUnderstanding the strengths and use-cases of each will help you write cleaner, more maintainable Spring applications.\n","date":"31 July 2025","externalUrl":null,"permalink":"/posts/component-vs-bean/","section":"Posts","summary":"\u003cp\u003eSpring Framework provides a powerful \u003cstrong\u003eDependency Injection (DI)\u003c/strong\u003e mechanism to manage application components. In this system, objects are managed by an \u003cstrong\u003eIoC (Inversion of Control)\u003c/strong\u003e container. But how do we tell Spring which classes or objects it should manage?\u003c/p\u003e","title":"Component vs Bean in Spring","type":"posts"},{"content":"","date":"22 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"When it comes to object-oriented programming languages, C# and Java are two of the most widely used and highly regarded languages in the software development world. Despite their similarities, they have distinct differences that set them apart in terms of syntax, platform compatibility, performance, and ecosystem. This article will provide an in-depth comparison of Java and C# to help you decide which one is best for your next project.\nOverview # C#, developed by Microsoft in 2000 as part of the .NET framework, was initially a Windows-based language. Over time, with the advent of .NET, C# has become a cross-platform language, supporting Windows, Linux, and macOS.\nJava was created by Sun Microsystems (now owned by Oracle) in the mid-1990s, with a primary focus on portability and cross-platform compatibility. It is widely used in enterprise environments, web applications, and Android development.\nSimilarities Between C# and Java # Object-Oriented: Both Java and C# are purely object-oriented languages, following OOP principles like encapsulation, inheritance, and polymorphism. Garbage Collection: Both languages have automatic memory management via garbage collection, which helps avoid memory leaks by reclaiming unused memory. Cross-Platform Support: Although Java traditionally offered the advantage of \u0026ldquo;Write Once, Run Anywhere\u0026rdquo; with the Java Virtual Machine (JVM), C# has also become a cross-platform language with .NET, now known as .NET 9/10. Multithreading: Both Java and C# have robust support for multithreading and concurrent programming, making it easier to build high-performance applications. Key Differences Between C# vs Java # 1. Platform Independence # C#: C# was initially confined to the Windows platform using the .NET Framework. However, .NET (now .NET 9/10) allows C# to run on multiple platforms, including Linux and macOS, making it a viable choice for cross-platform development.\nJava: Java is well-known for its platform independence. Java code is compiled to bytecode, which can be executed on any platform with a JVM, enabling it to run on Windows, Linux, macOS, and other systems without modification.\n2. Syntax and Features # C#: C# has more modern features, such as properties, events, delegates, and LINQ (Language Integrated Query). It supports more advanced constructs, including async/await for asynchronous programming. This makes C# a more feature-rich and flexible language.\nJava: Java‚Äôs syntax is slightly more verbose compared to C#. Java uses exceptions and error handling mechanisms such as try-catch blocks, and it does not have built-in support for properties, delegates, or events.\n3. Performance # C#: C# tends to have faster startup times and slightly better raw performance due to its compilation to Intermediate Language (IL), which is executed by the Common Language Runtime (CLR). C# has more direct access to Windows APIs and can be more optimized for desktop applications.\nJava: Java is slower in terms of startup time, but its performance improves over time thanks to Just-In-Time (JIT) compilation by the JVM. Java is often considered a bit slower compared to C# in terms of execution speed but can be highly optimized for server-side applications.\n4. Ecosystem and Frameworks # C#: C# is closely tied to the .NET Framework and the .NET ecosystem. It supports ASP.NET for web development, WinUI and WPF (Windows Presentation Foundation) for desktop applications, and .NET MAUI for mobile development. The .NET ecosystem continues to grow, and C# is gaining traction in areas like cloud computing and cross-platform apps.\nJava: Java has a vast ecosystem, especially for enterprise applications, Android development, and big data platforms. Popular frameworks like Spring (for web development) and Hibernate (for ORM) are widely used in the Java world.\n5. Development Tools # C#: C# developers primarily use Microsoft Visual Studio, one of the most feature-rich IDEs available. Visual Studio offers robust debugging tools, IntelliSense, and integrates seamlessly with Azure, SQL Server, and other Microsoft products.\nJava: Java developers typically use IntelliJ IDEA, Eclipse, or NetBeans for development. These IDEs offer rich features and plugins for Java development, including debugging, code completion, and refactoring tools.\n6. Use Cases # C#:\nWindows Applications: C# is the language of choice for desktop applications on Windows, particularly using **WinUI\u0026quot;, WPF and WinForms. Web Development: ASP.NET is a robust framework for web development with C#, used for building scalable and high-performance web applications. Game Development: C# is widely used in game development, particularly with the Unity engine. Cross-Platform Development: C# with .NET MAUI allows for the creation of cross-platform mobile applications. Java:\nEnterprise Applications: Java is highly favored in large-scale enterprise environments, especially in finance, government, and healthcare sectors. Android Development: Java was the primary language for Android app development (though Kotlin has become more popular in recent years). Big Data: Java is heavily used in big data technologies like Apache Hadoop and Apache Spark. Cloud Computing: Java is widely used in cloud-based applications, particularly in Amazon Web Services (AWS). 7. Community and Job Market # C#: C# is widely used within the Microsoft ecosystem and is also increasingly popular in the gaming industry due to Unity. The rise of .NET has made C# a strong candidate for cloud-based applications and cross-platform development, making C# developers highly sought after, particularly in game development and enterprise application development.\nJava: Java has a massive and mature community, with a strong presence in enterprise applications, Android development, and backend systems. There is always high demand for Java developers, especially for roles in enterprise environments, big data, and cloud computing.\nConclusion # Both C# and Java are powerful, versatile languages that have stood the test of time. The choice between Java and C# largely depends on the platform, the type of application, and the development tools you prefer.\nIf you are working with the Microsoft tech stack, developing for Windows desktop apps, or interested in game development with Unity, C# would be ideal. If you are developing for cross-platform environments, need portability, or are working with Android, Java is a strong choice. Ultimately, both languages offer robust features, strong communities, and solid performance. Understanding their strengths and weaknesses will help you decide which is best suited for your specific project.\n","date":"28 March 2025","externalUrl":null,"permalink":"/posts/csharp-vs-java/","section":"Posts","summary":"\u003cp\u003eWhen it comes to object-oriented programming languages, \u003cstrong\u003eC#\u003c/strong\u003e and \u003cstrong\u003eJava\u003c/strong\u003e are two of the most widely used and highly regarded languages in the software development world. Despite their similarities, they have distinct differences that set them apart in terms of syntax, platform compatibility, performance, and ecosystem. This article will provide an in-depth comparison of Java and C# to help you decide which one is best for your next project.\u003c/p\u003e","title":"C# vs Java","type":"posts"},{"content":"","date":"28 March 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"28 March 2025","externalUrl":null,"permalink":"/tags/techcomparison/","section":"Tags","summary":"","title":"TechComparison","type":"tags"},{"content":"Generally speaking, Java isn‚Äôt the most beloved language out there. It requires writing a lot more code, has many rules, and you often need to add extra libraries for things that come built-in with other languages. On top of that, Oracle‚Äôs history with licensing lawsuits has given Java a bad reputation among many developers. But despite all that, I still like Java more. I know its flaws, but its strengths mean more to me. Below, I want to explain why ‚Äî with some practical reasons.\n1. Static Typing ‚Äì Catching Errors Early # In Java, you have to declare variable types explicitly before using them. It may feel like a hassle at first, but in big projects, it really helps.\nFor example, in Python, you can define a function that adds two values, but if you accidentally pass a string and a number, it will crash at runtime. Java, on the other hand, catches this kind of mistake before the program even runs. This difference can save a lot of debugging time in complex systems.\n2. Performance ‚Äì Safer for Long-Running Tasks # Java runs on the JVM and is much faster than Python. This matters in large-scale data processing, server-side applications, or services that run continuously.\nFor instance, reading and processing millions of log entries usually completes faster and more efficiently in Java than in Python.\n3. C-Style Syntax ‚Äì Feeling More Disciplined While Coding # Some developers find Java‚Äôs syntax ‚Äî with curly braces, semicolons, and keywords like public static void ‚Äî overly verbose. But I find this structure helpful. It forces discipline and makes the code more predictable, especially in large teams or enterprise environments.\n4. OOP ‚Äì Breaking Down Software into Pieces # Java takes object-oriented programming seriously. It encourages you to define proper classes, methods, constructors, and access controls. This can feel tedious in small scripts but becomes essential in larger applications.\nIn contrast, while Python supports OOP, it allows looser structure, which can lead to messier codebases over time.\n5. Spring and Ecosystem ‚Äì Building Large Systems with Ready Solutions # Java‚Äôs Spring Framework provides everything you need to build robust, secure, and scalable enterprise applications ‚Äî from REST APIs to microservices and database integration. Python has powerful frameworks too, like Django and Flask, but Spring is more mature and widely adopted in large corporations.\n6. IDE and Auto-Completion # Thanks to static typing and a clear structure, Java works beautifully with modern IDEs like IntelliJ IDEA. Auto-completion, real-time error detection, and refactoring tools are extremely accurate.\nWith Python, dynamic typing often makes IDE features less reliable. Sometimes the IDE can‚Äôt even guess what attribute comes after a dot.\n7. Testing Culture ‚Äì Standing Behind Your Code # Java has a strong testing culture. Using tools like JUnit, writing unit tests is straightforward and considered best practice. Most serious Java projects include tests from day one.\nPython supports testing too, but in many cases ‚Äî especially in smaller teams ‚Äî it tends to be more optional than enforced.\n8. Backward Compatibility # One of Java‚Äôs most underrated strengths is its commitment to backward compatibility. Code written 10 or even 20 years ago can often still compile and run on modern JVMs. Compare that to Python\u0026rsquo;s painful transition from version 2 to 3, which broke a lot of older code.\n9. Platform Independence # Java lives by the motto: ‚ÄúWrite once, run anywhere.‚Äù Thanks to the JVM, Java applications can run on Windows, Linux, macOS, and even Android with minimal modification. This kind of portability is invaluable for cross-platform development.\n10. The Satisfaction While Coding # This might be subjective, but it matters to me: when I write Java, I feel like I‚Äôm building a solid, durable structure. The strict rules and architectural clarity give me confidence. It feels like engineering, not just scripting.\nWhat About Python? # Python is a fantastic language ‚Äî no doubt about it. It‚Äôs great for automation, scripting, data science, AI, and quick prototyping. If speed and simplicity are your top priorities, Python absolutely shines.\nBut for building large, long-term software systems, Java still gives me more reliability and long-term satisfaction.\nFinal Word # Every language has strengths and weaknesses. I happily use Python when it‚Äôs the right tool for the job. But Java aligns better with how I like to build systems: with structure, clarity, and confidence.\nJava doesn‚Äôt always offer the easiest path ‚Äî but it often offers the strongest one.\n","date":"28 March 2025","externalUrl":null,"permalink":"/posts/why-i-like-java-more-than-python/","section":"Posts","summary":"\u003cp\u003eGenerally speaking, Java isn‚Äôt the most beloved language out there. It requires writing a lot more code, has many rules, and you often need to add extra libraries for things that come built-in with other languages. On top of that, Oracle‚Äôs history with licensing lawsuits has given Java a bad reputation among many developers. But despite all that, I still like Java more. I know its flaws, but its strengths mean more to me. Below, I want to explain why ‚Äî with some practical reasons.\u003c/p\u003e","title":"Why I Like Java More Than Python","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]